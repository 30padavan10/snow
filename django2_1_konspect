--Представление(контроллер)--
Любой контроллер-функция в качестве единственного обязательного параметра принимает экземпляр класса HttpRequest, хранящий различные сведения о полученном запросе: запрашиваемый интернет-адрес, данные, полученные от посетителя, служебную информацию от самого веб-обозревателя и пр. По традиции этот параметр называется request. 

В теле функции экземпляр класса HttpResponse (он объявлен в модуле django.http) будет представлять отправляемый клиенту ответ. 


--Марштруты--
При поступлении любого запроса от клиента Django разбирает его на составные части (чем занимается целая группа программных модулей, называемых посредники), извлекает запрошенный посетителем интернет адрес, удаляет из него все составные части, за исключением пути, который передает маршрутизатору. Последний последовательно сравнивает его с шаблонными адресами, записанными в списке маршрутов. Как только будет найдено совпадение, маршрутизатор выясняет, какой контроллер связан с совпавшим шаблонным адресом, и передает этому контроллеру управление. 

----Параметризованные запросы----
Предположим нам нужно отфильтровывать из модели определенные записи(с определенным атрибутом), например название рубрики. Чтобы контроллер, который будет отфильтровывать из модели объявления, относящиеся к выбранной рубрике, смог, собственно, их отфильтровать, он должен получить ключ рубрики.

Этот ключ удобнее всего передать в составе интернет-адреса, через GЕТ-параметр: /bboard/?rubric=<ключ рубрики>. Однако Django предлагает нам другую возможность выполнить передачу параметров в контроллер - непосредственно в составе пути интернет-адреса: bboard/<ключ рубрики> 

Для этого нужно указать маршрутизатору, какую часть пути считать URL-параметром, каков тип этого параметра, и какое имя у параметра.
urlpatterns = [
	path( '<int:rubric_id>/', by_ruЬric),
]
<> - параметр указывается в угловых скобках
int - тип целое число 
rubric_id - имя параметра

Чтобы передать параметр контроллеру контроллер-функция должна иметь помимо атрибута request еще и этот атрибут
	def by_rubric(request, rubric_id):
	
----Обратное разрешение интернет-адресов----
Если мы решим изменить шаблонный интернет-адрес в списке маршрутов, нам придется вносить уйму правок и в код шаблонов. Существует инструмент Django, называемый обратным разрешением интернет-адресов. Его суть: мы указываем маршрут, формирующий нужный нам интернет-адрес(значения URL-параметров - если требуется), а Django сам генерирует на основе всего этого правильный интернет-адрес. 
Для этого нужно:
1. Дать маршрутам имена, создав тем самым именованные маршруты.
	path ( '<int: rubric_id>/', by_rubric, name='by_rubric'),

2. Использование в гиперссылках тегов шаблонизатор url. Имя маршрута указывается первым параметром. Значение URL-параметра - вторым.
	<а href="{% url 'by_rubric' rubric.pk %}">
	
ВНИМАНИЕ! С именованными параметрами нужно быть внимательным.
Если формируем ссыллку внутри цикла из модели Rubric, то обращаемся к параметру как rubric.pk:
{% for rubric in rubrics %}
    <a href="{% url 'by_rubric' rubric.pk %}">{{ rubric.name }}</a>	
А если формируем ссылку внутри цикла из модели Bb, то обращаться к параметру нужно уже как bb.rubric.pk:
{% for bb in bbs %}
    <p><a href="{% url 'by_rubric' bb.rubric.pk %}">{{ bb.rubric.name }}</a></p>

--Модель--
Модель - это описание сущности, хранящейся в базе данных в виде класса Python. Класс модели описывает таблицу базы данных,в которой будет храниться набор сущностей, и атрибуты класса, каждый из которых описывает одно из полей таблицы. Можно сказать, что модель это представление таблицы и ее полей средствами Python. 
Отдельный экземпляр класса модели представляет отдельную конкретную сущность, извлеченную из базы, т. е. отдельную запись соответствующей таблицы.
Пользуясь объявленными в модели атрибутами класса, мы можем получать значения, хранящиеся в полях записи, равно как и записывать в них новые значения. 

Все классы моделей поддерживают атрибут класса objects. Он хранит диспетчер записей - особую структуру, позволяющую манипулировать всей совокупностью имеющихся в модели записей. Диспетчер записей представляется экземпляром класса Manager.

По поводу низкоуровневых структур, создаваемых в базе данных и используемых моделью для хранения сущностей, можно отметить следующее:
- каждая модель представляет отдельную таблицу в базе данных;
- по умолчанию таблицы, представляемые моделями, получают имена вида <псевдоним приложения>_<имя класса модели> (в данном случае будет bboard_bb);
- каждое поле модели представляет отдельное поле в соответствующей таблице базы данных;
- по умолчанию поля в таблице получают имена, совпадающие с именами полей модели, которые их представляют(в данном случае  title, content, price ...);
- если в модели не было явно объявлено ключевое поле для хранения значения, однозначно идентифицирующего запись модели (ключа), оно будет создано самим фреймворком, получит имя id, целочисленный тип, будет помечено как автоинкрементное, и для него будет создан ключевой индекс;
- по умолчанию никакие дополнительные индексы в таблице не создаются.

Модель может быть создана для представления как уже существующей в базе таблицы (в этом случае при объявлении модели нам придется дополнительно указать
имя таблицы и имена всех входящих в нее полей), так и еще не существующей (тогда для создания таблицы нам нужно сгенерировать миграцию).


Метод create () диспетчера записей создает новую запись модели, принимая в качестве набора именованных параметров значения ее полей. При этом он сразу же сохраняет созданную запись и возвращает ее в качестве результата. 

Метод all ( ) диспетчера записей возвращает набор записей. Сам набор записей представляется экземпляром класса Queryset, а отдельные записи - экземплярами соответствующего класса модели. Поскольку набор записей является последовательностью и поддерживает итерационный протокол, мы можем перебрать его в цикле. 

Метод order_Ьу ( ) диспетчера записей сортирует записи по значению поля, чье имя указано в параметре.(for Ь in Bb.objects.order_by('title'))
Метод filter () диспетчера записей выполняет фильтрацию записей по заданным критериям.(for Ь in Bb.objects.filter(title='Дoм'))
Метод get ( ) диспетчера записей имеет то же назначение, что и метод fi1ter( ), и вызывается аналогичным образом. Однако он ищет не все записи, подходящие под заданные критерии, а лишь одну и возвращает ее в качестве результата. К тому же, он работает быстрее метода filter(). 


Вложенный класс Mеtа содержит атрибуты класса, которые задают параметры самой модели:
verbose_name_plural - название модели во множественном числе;
verbose_name - название модели в единственном числе.
Эти названия также будут выводиться на экран в админке сайта.
ordering - последовательность полей, по которым по умолчанию будет выполняться сортировка записей. 

Параметры поддерживаемые всеми типами полей:
- verbose_name указывает "человеческое" название поля, которое будет выводиться на экран на страницах административного сайта и напротив элементов управления в веб-формах. Если оно не указано, в таковом качестве будет использовано имя поля.
- help_text - дополнительный поясняющий текст, выводимый на экран. Значение по умолчанию - пустая строка. 
- unique - если True, в текущее поле может быть занесено только уникальное в пределах таблицы значение (уникальное поле). При попытке занести значение, уже имеющееся в том же поле другой записи, будет возбуждено исключение IntegrityError из модуля django.db. Если поле помечено как уникальное, по нему автоматически будет создан индекс. Поэтому явно задавать для него индекс не нужно. 
- null - если True, поле в таблице базы данных может хранить значение null и, таким образом, являться необязательным к заполнению. Параметр null затрагивает только поле таблицы, но не поведение Django. Даже если какое-то поле присвоением параметру значения тrue было помечено как необязательное, фреймворк по умолчанию все равно не позволит занести в него пустое значение;
-blank - если тrue, Django позволит занести в поле пустое значение, тем самым сделав поле необязательным к заполнению. Параметр blank задает поведение самого фреймворка при выводе на экран веб-форм и проверке введенных в них данных. Если для этого параметра бьmо указано значение true, Django позволит занести в поле пустое значение (например, для строкового поля - пустую строку), даже если это поле было помечено как обязательное к заполнению (параметру null было дано значение False);
- choices - последовательность значений, доступных для занесения в текущее поле. Может быть использован для создания полей, способных хранить ограниченный набор значений, которые посетитель выбирает из списка(поле со списком). Если значение поля должно быть текстовым, то и значение 1-го элемента должно быть текстовое и т.д.

class Bb(models.Model):
КINDS = (
( 'b', 'Куплю'),
( 's' , ' Продам' ) ,
( 'с' , 'Обменяю' ) ,
)

kind = models.CharField(max_length=l, choices=KINDS) 

- db_index - если True, по текущему полю в таблице будет создан индекс, если False - не будет. Значение по умолчанию- False;
- primary_key - если True, текущее поле станет ключевым. При этом ключевое поле будет помечено как обязательное к заполнению и уникальное (параметру null неявно будет присвоено значение False, а параметру unique - True).

----Редактор модели в админке сайта----
На странице списка записей в админке все позиции представляются невразумительными строками вида <имя класса модели> object (<значение ключа>)" из которых невозможно понять, что же хранится в каждой из этих записей. Но можно вывод данной информации редактировать.

В admin.py создаем редактор модели, который объявляется как подкласс admin.ModelAdmin и с помощью атрибута list_display указываем какие поля записи должны отображаться. 
list_display_links - создает ссылку на редактирование записи,
search_fields - добавляет поле для поиска.

class BbAdmin(admin.ModelAdmin):
	list_display = ('title', 'content', 'price', 'published')
	list_display_links = ('title', 'content')
	search_fields = ('title', 'content',)
admin.site.register(Bb, BbAdmin) 

Этот способ лучше всего подходит только для моделей с несколькими значащими полями, если же такое поле в модели всего одно, проще переопределить метод __str__ в самой модели.

class Rubric(models.Model):
	def __str__(self) :
		return self.name 


----Связь между моделями----

"один со многими"
Для связи между моделями во вторичную модель добавляется внешний ключ, устанавливающий связь между этой модель и записью первичной модели. Таким образом будет создана связь "один со многими".

rubric = models.ForeignKey('Rubric', null=Тrue, on_delete=models.PROTECT, vеrbоsе_name='Рубрика')

Первым параметром:
- Rubric - ссылка на класс - если код, объявляющий класс первичной модели, располагается перед кодом класса вторичной модели; 
- 'Rubric' - строки с именем класса - если вторичная модель объявлена раньше первичной
- Если необходимо передать ссылку на модель, объявленную в другом приложении проекта, необходимо использовать строку формата <имя прwюжения>.<имя класса модели>: 'rubrics.Rubric'
- Если нужно создать модель, ссылающуюся на себя (создать рекурсивную связь), первым параметром конструктору следует передать строку 'self'. 

null=Тrue Все поля, создаваемые в моделях, по умолчанию обязательны к заполнению. Следовательно, добавить новое, обязательное к заполнению поле в модель, которая
уже содержит записи, нельзя - сама СУБД откажется делать это и выведет сообщение об ошибке. Нам придется явно пометить поле ruЬric как необязательное,
присвоив параметру null значение true - только после этого поле будет успешно добавлено в модель. 

Параметр on_delete управляет каскадными удалениями записей вторичной модели после удаления записи первичной модели, с которой они были связаны.
- CASCADE - удаляет все связанные записи вторичной модели (каскадное удаление); 
- РRОТЕСТ - возбуждает исключение ProtectedError из модуля django.db.models, тем самым предотвращая удаление записи первичной модели;
- SET_NULL - заносит в поле внешнего ключа всех связанных записей вторичной модели значение null. Сработает только в том случае, если поле внешнего ключа объявлено необязательным к заполнению на уровне базы данных (параметр null конструктора поля имеет значение True);
- SET_DEFAULT- заносит в поле внешнего ключа всех связанных записей вторичной модели заданное для него значение по умолчанию. Сработает только в том
случае, если у поля внешнего ключа бьmо указано значение по умолчанию (оно задается параметром default конструктора поля);
- SET (<значение>) - заносит в поле внешнего ключа указанное значение

Параметр limit_choices_to - позволяет вывести в списке связываемых записей первичной модели только те, что удовлетворяют заданным критериям фильтрации. 
Для примера укажем Django выводить только рубрики, поле visible которых содержит значение тrue:
	rubric = models.ForeignКey(Rubric, on_delete=models.PROTECT, limit_choices_to={'visible': True}) 

Параметр related_name - для доступа к записям вторичной модели через значение атрибута записи первичной модели.
	class Bb(models.Model):
		rubric = models.ForeignKey(Rubric, on_delete=models.PROTECT,related_name='entries')

# Получаем первую рубрику
first_rubric = Rubric.objects.first()
# Получаем доступ к связанным объявлениям через атрибут entries, указанный в параметре related_name
bbs = first_rubric.entries.all() 


---- Выборка полей модели -------

Посмотреть sql-запрос b = Bb.objects.filter(price__gte=10000).query 

При выборке набора записей Django извлекает из таблицы значения полей только текущей модели. При обращении к полю связанной модели фреймворк выполняет дополнительный SQL-запрос для извлечения содержимого этого поля, что может снизить производительность.

Помимо этого, выполняется выборка значений из всех полей текущей модели. Если какие-то поля хранят данные большого объема (например, большой текст), их выборка займет много времени и отнимет существенный объем оперативной памяти.

Далее приведены методы, поддерживаемые диспетчером записей (классом Manager) и набором записей (классом QuerySet), которые позволяют управлять выборкой значений полей:

select_related (<поле внешнего ключа 1>, <поле внешнего ключа 2> . . . <поле внешнего ключа n>) — будучи вызван у записи вторичной модели, указывает извлечь связанную запись первичной модели. В качестве параметров записываются имена полей внешних ключей, устанавливающих связь с нужными первичными моделями.
Метод извлекает единичную связанную запись. Его можно применять только в моделях, связанных связью "один-с-одним", и вторичных моделях в случае
связи "один-со-многими".

from bboard.models import Bb

b = Bb.objects.get(pk=l)
# Никаких дополнительных запросов к базе данных не выполняется,
# т. к. значение поля title, равно как и значения всех прочих
# полей текущей модели, уже извлечены
b.title
’Дача'
# Но для извлечения полей записи связанной модели выполняется
# отдельный запрос к базе данных
b.rubric.name
'Недвижимость'
# Используем метод select_related(), чтобы выбрать поля и текущей,
# и связанной моделей в одном запросе
b = Bb.objects.select_related(’rubric’).get(pk=l)
# Теперь отдельный запрос к базе для извлечения значения поля
# связанной модели не выполняется
b. rubric .name
'Недвижимость'

Предположим, что модель Bb связана с моделью Rubric, которая, В СВОЮ очередь, связана С моделью SuperRubric через поле внешнего ключа super rubric и является вторичной для этой модели. Тогда МЫ можем ВЫПОЛНИТЬ выборку связанной записи модели SuperRubric, написав выражение вида:
b = Bb.objects.select_related(’rubric__super_rubric').get(pk=l)
Можно выполнять выборку сразу нескольких связанных моделей, написав такой код:
b = Bb.objects.select_related(’rubric’, ’rubric__super_rubric’).get(pk=l)



prefetch_related (<связь 1>, <связь 2> . . . ссвязь n>) — будучи вызван у записи первичной модели, указывает извлечь все связанные записи вторичной модели.
Метод извлекает набор связанных записей. Он применяется в моделях, связанных связью "многие-со-многими", и первичных моделях в случае связи "один-со-многими”.

В качестве связи можно указать:
	
	- строку с именем:
		- атрибута, применяющегося для извлечения связанных записей, если метод вызывается у записи первичной модели, и установлена связь "один-со-многими":
from bboard.models import Rubric

r = Rubric.objects. first ()
r
<Rubric: Бытовая техника>
# Здесь для извлечения каждого объявления, связанного
# с рубрикой, выполняется отдельный запрос к базе данных
for bb in r.bb_set.all(): print(bb.title, end=’ ’)
Пылесос Стиральная машина
# Используем метод prefetch_related(), чтобы извлечь все
# связанные объявления в одном запросе
r = Rubric.objects.prefetch_related(’bb_set’).first()
for bb in r.bb_set.all(): print(bb.title, end=* ')
Пылесос Стиральная машина
		
		- поля внешнего ключа — если установлена связь "многие-со-многими":
from testapp.modeIs import Machine, Spare
# Указываем предварительно извлечь все связанные
# с машиной составные части
m = Machine.objects.prefetch_related(’spares’).first()
for s in m.spares.all(): print(s.name, end=’ ’)
Гайка Винт

	- экземпляр класса Prefetch
Вызывается из модуля django.db.models, хранящий все необходимые сведения для выборки записей. Конструктор этого класса вызывается в формате: Prefetch(<связь>[, queryset=None][, to_attr=None])
Связь указывается точно так же, как было описано ранее. 
Необязательный параметр queryset задает набор записей для выборки связанных записей. В этом наборе записей можно указать какую-либо фильтрацию, сортировку или предварительную выборку полей связанных записей методом select_related.
Необязательный параметр to attr позволяет указать имя атрибута, который будет создан в объекте текущей записи и сохранит набор выбранных записей
связанной модели.

from django.db.modeIs import Prefetch
# Выполняем выборку объявлений, связанных с рубрикой,
# с одновременной их сортировкой по убыванию названия
pr1 = Prefetch(’bb_set’, queryset=Bb.objects.order_by(’-title’))
r = Rubric.objects.prefetch_related(pr1).first()
for bb in r.bb_set.all(): print(bb.title, end=’ ’)
Стиральная машина Пылесос
# Выполняем выборку только тех связанных объявлений,
# в которых указана цена свыше 1 000 руб., и помещаем
# получившийся набор записей в атрибут expensive
# объекта рубрики
pr2 = Prefetch ('bb_set', queryset=Bb.objects.filter(price__gt=1000), to_attr=’expensive’)
r = Rubric.objects.prefetch_related(pr2).first()
for bb in r.expensive: print(bb.title, end=' ’)
Стиральная машина



defer(<имя поля 1>, <имя поля 2> . . . <имя поля n>) — указывает не извлекать значения полей с заданными именами в текущем запросе. Для последующего
извлечения значений этих полей будет выполнен отдельный запрос к базе данных. Пример:
bb = Bb.objects.defer(’content’).get(pk=3)
# Никаких дополнительных запросов к базе данных не выполняется,
# поскольку значение поля title было извлечено в текущем запросе
bb.title
’Дом’
# А значение поля content будет извлечено в отдельном запросе,
# т. к. это поле было указано в вызове метода defer()
bb.content
’Трехэтажный, кирпич’



only (<имя поля 1>, <имя поля 2> . . . <имя поля n>) — указывает не извлекать значения всех полей, кроме полей с заданными именами, в текущем запросе. Для последующего извлечения значений полей, не указанных в вызове метода, будет выполнен отдельный запрос к базе данных. Пример:
bb = Bb.objects.only(’title', 'price').get(pk=3)


Связи "многие-со-многими" с дополнительными данными например количеством штук хорошо описано в 16.2



--Миграции--
Миграция - это модуль Python, созданный самим Django на основе определенной модели и предназначенный для формирования в базе данных всех требуемых этой моделью структур: таблиц, полей, индексов, правил и связей.


--Шаблоны--
Шаблон - это образец для формирования документа, который будет представлен клиенту. Подсистема Django, называемая шаблонизатором, загружает шаблон, объединяет его с данными, извлеченными из моделей, полученными от посетителя или сгенерированными в процессе работы, и формирует на основе всего этого полноценный документ, который и отправляется клиенту. 

Применительно к веб-страницам, шаблон - это файл с НТМL-кодом страницы, содержащий особые команды шаблонизатора: директивы, теги и фильтры. Директивы указывают поместить в заданное место НТМL-кода какое-либо значение, теги управляют генерированием содержимого результирующего документа, а филътры выполняют какие-либо преобразования указанного значения перед выводом.

В шаблон можно добавлять переменные из разных моделей одновременно например из Bb и Rubric. В модели Bb есть параметр rubric, который является ForeignKey от Rubric. Таким образом можно получить доступ к параметрам Rubric через Bb - bb.rubric.name

----Наследование шаблонов----

Шаблон, являющийся базовым, объявляет в составе своего содержимого так называемые блоки. Они определяют место в шаблоне, куда будет вставлено содержимое, извлеченное из шаблонов, которые станут производными по отношению к базовому. Каждый из блоков имеет уникальное в пределах шаблона имя.

Объявленный в базовом шаблоне блок может быть как пустым:
	{% blосk content %}
	{% endblock %}

так и иметь какое-либо изначальное содержимое: 
	{% blосk title %}Главная{% endblock %}

Это содержимое будет присутствовать в блоке, если производный шаблон не задаст для него свое содержимое.

В производном шаблоне:
	{% extends "layout/basic.html" %}  
	{% blосk content %}
	...
	{% endblock %}
	
Путь к базовому шаблону указывается от папки templates. В данном примере файл basic.html находится в templates>layout>. Если бы файл находился в templates>bboard>layout>, то путь выглядел бы {% extends "bboard/layout/basic.html" %} 

По умолчанию Джанго ищет шаблоны в папке с приложением, либо приложение/templates/название_приложения/шаблон.html
Чтобы добавить для поиска дополнительные папки в settings в TEMPLATES в 'DIRS' добавить os.path.join(BASE_DIR, 'templates') или другие пути 


Для поля ImageField в шаблоне используется не атрибут модели типа movie.poster, а movie.poster.url

	
--Формы--
Для ввода данных язык HTML предлагает так называемые веб-формы.
Объявляется класс формы, связанной с моделью. Такая форма «умеет» генерировать теги, что создадут входящие в состав формы элементы управления, проверять на корректность введенные данные и, наконец, сохранять их в модели, с которой она связана. 

Класс формы, связанной с моделью, является производным от класса Mode!Form из модуля django.forms. В классе формы вложенный класс Meta, в котором указываются параметры нашей формы: класс модели, с которой она связана (атрибут класса model), и последовательность из имен полей модели, которые должны присутствовать в форме (атрибут класса fields).

Обрабатывать формы, связанные с моделью, можно в знакомых нам контроллерах-функциях. Но также можно применять высокоуровневый контроллер-класс, который возьмет большую часть действий по выводу и обработке формы на себя - CreateView.

class BbCreateView(CreateView):
    template_name = 'bboard/create.html'
    form_class = BbForm
    success_url = '/bboard/'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['rubrics'] = Rubric.objects.all()
        return context
		
Контроллер-класс мы сделали производным от класса CreateView из модуля django.views.generic.edit. Базовый класс реализует функциональность по созданию формы, выводу ее на экран с применением указанного шаблона, получению занесенных в форму данных, проверке их на корректность, сохранению их в новой записи модели и перенаправлению в случае успеха на интернет-адрес, который мы зададим.

template_name - путь к файлу шаблона, который будет использован для вывода страницы с формой;
form_class - сам класс формы, связанной с моделью;
success_url - интернет-адрес, по которому будет выполнено перенаправление после успешного сохранения данных (в нашем случае это адрес главной страницы). 

В success_url можно вместо статического адреса записывать обратный интернет-адрес с помощью функции reverse_lazy().
Функция reverse_lazy() из модуля django.urls в качестве параметров принимает имя маршруrа и значения всех входящих в маршрут URL-параметров (если они там есть). Результатом станет готовый интернет-адрес. 

Метод get_context_data() нужен для того чтобы на страницу с формой вывести панель с рубриками.
Метод get_context_data() этого класса формирует контекст шаблона. Мы переопределили метод, чтобы добавить в контекст дополнительные данные - список
рубрик. В теле этого метода мы сначала получаем контекст шаблона от метода базового класса, затем добавляем в него список рубрик и, наконец, возвращаем
в качестве результата. 

В шаблоне формы:
	<form method="post">
		{% csrf_token %)
		{{ form.as_p ))
		<input type="submit" vаluе="Добавить">
	</form> 

- форма в контексте шаблона хранится в переменной form. Эту переменную создает базовый класс CreateView;
- в выводе формы, чтобы элементы управления находятся на отдельных абзацах, для переменной form применяется метод as_p() класса ModelForm ;
-  метод as_p() генерирует только код, создающий элементы управления. Тег <form>, необходимый для создания самой формы, и тег <input>, формирующий
кнопку отправки данных, добавляются самостоятельно.
- в теге <form> мы указали метод отправки данных POST, но не записали интернет-адрес, по которому будут отправлены занесенные в форму данные. В этом случае данные будут отправлены по тому же интернет-адресу, с которого была загружена текущая страница, т.е. в нашем случае, тому же контроллеру-классу BbCreateView, который благополучно обработает и сохранит их;
-  в теге <form> мы поместили тег шаблонизатора csrf_token. Он создает в форме скрытое поле, хранящее цифровой жетон, получив который, контроллер «поймет», что данные бьли отправлены с текущего сайта, и им можно доверять. Это часть подсистемы обеспечения безопасности Django.

В модуль urls добавляем путь:
	path('add/', BbCreateView.as_view(), name='add' ),
 
В вызов функции раth( ) в таком случае подставляется не ссылка на сам контроллер-класс, а результат, возвращенный методом as_view() контроллера-класса. 

------формирования ответа------

Формированием ответа на самом низком уровне занимается класс HttpResponse из модуля django.http.

from django.http import HttpResponse

def index(request):
	resp = HttpResponse("Здесь будет", content_type='text/plain; charset=utf-8’)
	resp.write(’ главная’)
	resp.writelines((’ страница’, ’ сайта’))
	resp['keywords’] = ’Python, Django’
return resp

Применять низкоуровневые средства для создания ответа на практике приходится крайне редко. Гораздо чаще мы имеем дело с высокоуровневыми средствами — шаблонами.

-----Формирование ответа на основе шаблона-------

Для загрузки нужного шаблона Django предоставляет две функции, объявленные В модуле dj ango. template. loader:
get_tempiate, select_template

Для получения обычной веб-страницы нужно выполнить рендеринг шаблона, вызвав метод render:

from django.http import HttpResponse
from django.template.loader import get_template

def index(request):
	bbs = Bb.objects.all()
	rubrics = Rubric.objects.all()
	context = {’bbs’: bbs, ’rubrics’: rubrics}
	template = get_template(’bboard/index.html')
	return HttpResponse(template.render(context=context,request=request))
	
Помимо класса HttpResponse, ответ можно сформировать с помощью аналогичного класса TemplateResponse ИЗ модуля django. template, response.
Основное преимущество класса TemplateResponse проявляется при использовании посредников, добавляющих в контекст шаблона дополнительные данные. Этот класс поддерживает отложенный рендеринг шаблона, выполняющийся только после ’’прохождения” всей цепочки зарегистрированных в проекте посредников, непосредственно перед отправкой ответа клиенту. Благодаря этому посредники, собственно, и могут добавить в контекст
шаблона дополнительные данные.
Кроме того, в виде экземпляров класса TemplateResponse генерируют ответы все высокоуровневые контроллеры-классы.

from django.template.response import TemplateResponse

def index(request):
	bbs = Bb.objects.all()
	rubrics = Rubric.objects.all()
	context = {’bbs’: bbs, ’rubrics’: rubrics}
	return TemplateResponse(request, 'bboard/index.html ’,	context=context)
	
	
Шаблон — это образец для генерирования веб-страницы, отправляемой клиенту в ответ на его запрос. Django также использует шаблоны для формирования электронных писем.
Рендеринг — собственно генерирование веб-страницы (или электронного письма) на основе заданного шаблона и контекста шаблона, содержащего все необходимые данные.
Шаблонизатор — подсистема фреймворка, выполняющая рендеринг.(DjangoTemplates, Jinja2)

	
	
Обработчик контекста — context_processors это программный модуль, добавляющий в контекст шаблона какие-либо дополнительные переменные уже после его формирования контроллером. 

Оработчики контекста удобно использовать, если нужно просто добавить в контекст шаблона какие-либо данные. Обработчики контекста реализуются проще, чем посредники, и работают в любом случае, независимо от того, представлен ответ экземпляром класса TemplateResponse ИЛИ HttpResponse

------Сокращения--------

Сокращение — это функция, выполняющая сразу несколько действий. Применение сокращений позволяет несколько уменьшить код и упростить программирование.
Все сокращения, доступные в Django, объявлены в модуле django.shortcuts:
render, redirect, get_object_or_404, get_iist_or_404

------Валидаторы--------
Валидацией называется проверка на корректность данных, занесенных в поля модели.
Валидацию можно реализовать непосредственно в модели или же в форме, которая используется для занесения в нее данных.

Валидацию значений, заносимых в отдельные поля модели, выполняют валидаторы. реализованные в виде функций или классов. Некоторые типы полей уже используют определенные валидаторы — так, строковое поле CharField задействует валидатор MaxLengthVaiidator, проверяющий, не превышает ли длина заносимого строкового значения указанную максимальную длину.

Помимо этого, можно указать для любого поля другие валидаторы, предоставляемые Django. Реализующие их классы объявлены в модуле django.core.validators.

from django.core import validators

class Bb(models.Model):
	title = models.CharField(max_length=50, validators=[validators.RegexValidator(regex='^.{4,}$')])
	
Здесь использован валидатор, представляемый классом RegexValidator. Он проверяет заносимое в поле значение на соответствие заданному регулярному выражению.

RegexValidator(regex=None[, message=None][, code=None][,inverse_match=None][, flags=0])


Если нужный валидатор отсутствует в стандартном наборе, мы можем написать его самостоятельно, реализовав его в виде функции или класса.
Валидатор, выполненный в виде функции, должен принимать один параметр — значение, которое следует проверить. Если значение некорректно, то функция
должна возбудить исключение ValidationError ИЗ МОДУЛЯ django. core. exceptions. Возвращать результат она не должна

Валидатор описывать в моделях???

from django.core.exceptions import ValidationError

def validate_even(val):
	if val % 2 != 0:
		raise ValidationError(’Число %(value)s нечетное’, code=’odd’,params={’value': val})

Этот валидатор указывается для поля точно так же, как и стандартный:
class Bb (models .Model) :
	price = models.FloatField(validators=[validate_even])
	
	
----Аутентификация пользователя ----

Django использует sessions и Middleware для подключения системы аутентификации к request objects.

Они обеспечивают атрибут request.user в каждом запросе, который представляет текущего пользователя. Если текущий пользователь не вошел в систему, этот атрибут будет установлен в экземпляр AnonymousUser, в противном случае это будет экземпляр User.


AuthenticationMiddleware: проверяет что есть в request запросе сессии, пытается получить пользователя в request запросе: проверяет в сессии _cached_user, если нет проверяет есть ли в сессии id пользователя и backend_path. Если есть хэш сессии, то сравнивает его с получением хэша для данного пользователя, если все подтверждается, то пользователь аутентифиципрован и добавляется в request.user 

Middleware работает для каждого запроса когда пользователь открывает любую страницу(посылает любой запрос) 

А сам Вход пользователя в систему осуществляется через authenticate() и login()

from django.contrib.auth import authenticate, login

def my_view(request):
    username = request.POST['username']
    password = request.POST['password']
    user = authenticate(request, username=username, password=password)
    if user is not None:
        login(request, user)
        # Redirect to a success page.
        ...
    else:
        # Return an 'invalid login' error message.
        ...


authenticate(request=None, \**credentials)
authenticate() служит для проверки набора учетных данных. Она принимает учетные данные в качестве аргументов ключевых слов, username и password для случая по умолчанию, сверяет их с каждым authentication backend и возвращает объект User, если учетные данные действительны для бэкенда. Если учетные данные не действительны ни для одного бэкенда или если бэкенд поднимает PermissionDenied, возвращается None.

login() осуществляет добавление в сессию хэша пользователя, для того чтобы при каждом новом запросе не проходить аутентификацию.




----Аутентификация/авторизация пользователя через токены----

Аутентификация - процедура проверки подлинности, проверка имени и пароля в списке пользователей (т. е. является ли он зарегистрированным пользователем). Если такой пользователь в списке обнаружился, то он прошел аутентификацию(вход на сайт).

Авторизация - предоставление прав на выполнение определённых действий и процесс проверки (подтверждения) данных прав при попытке выполнения этих действий с конкретными данными на странице или с конкретной страницей.

Стандартная система аутентификации Django работает только с традиционными запросами - ответами HTML.

Исторически, когда пользователь хотел выполнить какое-то действие (например создать новый аккаунт), он заполнял определенную форму в браузере. Далее, когда он кликал на кнопку «Отправить», браузер формировал запрос — который включал в себя данные, введенные пользователем — и отправлял на сервер, сервер обрабатывал запрос, и отвечал либо HTML страницей, либо редиректом на новую страницу HTML.

Для авторизованных пользователей Django сохраняет CSRF токен в сессиях. Этот самый токен хранится в куках. Сама сессия хранится в базе данных и привязывается к определённому пользователю, но гуляя между фронтом и бэком -- она находится в куках (в подавляющем большинстве случаев)

Но когда мы используем отдельный фронтенд не на шаблонах Django или приложение на телефоне, то у Django нет возможности использовать куки, в таком случае приходится отказываться от стандартной системы аутентификации и использовать библиотеку djoser. 

djoser может работать как с обычными токенами, так и с JWT(JSON Web Tokens) токенами, так и с авторизацией через соц. сети

Обычные токены хранятся в БД, для них нужно выполнять доп. миграции чтобы создать таблицу в БД. 

JWT токены в БД не хранятся, а хранятся на стороне пользователя в браузере. Например их можно положить в LocalStorage браузера и они будут там храниться даже когда пользователь закроет или обновит вкладку.

Принцип получается следубщий изначально пользователя просят пройти аутентификацию, он вводит логин и пароль, в ответ на это в случае с JWT djoser возвращает 2 токена access и refresh. Их можно сохранить в LocalStorage, а затем при следующих запросах пользователя подставлять access токен в заголовок Authorization.

refresh токен используется когда истекает время access токена то через refresh токен можно обновить access токен не запрашивая у пользователя заново авторизоваться.
в тело запроса добавляется параметр refresh со значением refresh токена и возвращается один access токен который нужно подставлять вместо старого access токена

если время истекло и для access токена и refresh токена, то тогда уже нужно пользователю заново авторизовываться


библиотеки для jwt токенов есть разные, в инсталлед апп нужно добавлять подходящую и настройки этих библиотек в конфиге разные


c jwt можно работать и без djoser. Например если используем библиотеку Simple JWT, то в urls добавляются эндпоинты:
path(api/token/', jwt_views.TokenObtainPairView.as_view(), name='token_obtain_pair'),
path('api/token/refresh/', jwt_views.TokenRefreshView.as_view(), name='token_refresh'),

если мы используем дополнительно djoser, то у него в urls добавляется:
path('auth/', include('djoser.urls.jwt')), а сами эндпоинты будут:
auth/jwt/create
auth/jwt/refresh

но суть одна и таже.





---- settings----
---- модель User----
Если вы напрямую ссылаетесь на модель User (например, используя внешние ключи), ваш код не будет работать в проектах где стандартная модель заменена на другую в параметре конфигурации AUTH_USER_MODEL.

get_user_model()
Вместо того, чтобы ссылаться на модель User напрямую, вы должны делать это, используя метод django.contrib.auth.get_user_model(). Этот метод возвращает действующую модель, указанную в настройках приложения или стандартную модель User, в случае, если не изменялась.

from django.contrib.auth import get_user_model
User = get_user_model()


------Расширение модели пользователя в Django-----

Существует четыре разных способа расширения существующей модели пользователя, о которых пойдет речь в статье:

использование прокси-модели;
использование связи один-к-одному с пользовательской моделью;
создание модели пользователя с помощью расширения класса AbstractBaseUser;
создание модели пользователя с помощью расширения класса AbstractUser.

Использование прокси-модели
Прокси-модель — это модель, отнаследованная от существующей модели без создания новой таблицы в базе данных. Она используется для изменения поведения существующей модели, например, задания сортировки по умолчанию или добавления новых методов, не затрагивающих схему базы данных, или изменить Manager модели.

from django.contrib.auth.models import User
from .managers import PersonManager

class Person(User):
    objects = PersonManager()

    class Meta:
        proxy = True
        ordering = ('first_name', )

    def do_something(self):
        ...
		
использование связи один-к-одному с пользовательской моделью
В этом случае создается обычная модель Django, у которой будет собственная таблица базы данных и которая будет одна-к-одной связана с существующей моделью пользователя через OneToOneField.
Связь один-к-одному используется, когда нужно хранить дополнительную информацию о существующей модели пользователей, которая не связана с процессом аутентификации. Такую модель обычно называют профилем пользователя. Стоит понимать, что использование этой стратегии приводит к дополнительным запросам или объединениям для получения связанных данных.

from django.db import models
from django.contrib.auth.models import User
from django.db.models.signals import post_save
from django.dispatch import receiver

class Profile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    bio = models.TextField(max_length=500, blank=True)
    location = models.CharField(max_length=30, blank=True)
    birth_date = models.DateField(null=True, blank=True)

@receiver(post_save, sender=User)
def create_user_profile(sender, instance, created, **kwargs):
    if created:
        Profile.objects.create(user=instance)

@receiver(post_save, sender=User)
def save_user_profile(sender, instance, **kwargs):
    instance.profile.save()
	
Как можно видеть, основная нагрузка — это добавление вызовов create_user_profile и save_user_profile всякий раз, когда происходит сохранение (в том числе создание) объекта. Этот вид сигнала называется post_save. Вообще говоря, вам никогда не придется вызывать метод сохранения профиля. Все делается методами User.

Отдельно обсудим вопрос использования форм. Можно использовать на html странице более одной формы сразу. Во views используем соответствующий instance

def update_profile(request):
    if request.method == 'POST':
        user_form = UserForm(request.POST, instance=request.user)
        profile_form = ProfileForm(request.POST, instance=request.user.profile)

Эффект дополнительных запросов можно смягчить, используя метод select_related.

users = User.objects.all().select_related('profile')


создание модели пользователя с помощью расширения класса AbstractBaseUser

Это совершенно новая модель пользователя, которая наследуется от AbstractBaseUser. При выборе этого варианта настоятельно рекомендуется провести все манипуляции с моделями до начала работы над проектом, так как это повлияет на всю схему базы данных. Использование этого способа в готовом проекте может вызвать проблемы при внедрении новой модели. 

Использование пользовательской модели нужно тогда, когда приложение имеет особые требования к процессу аутентификации. Например, если вам нужно использовать адрес электронной почты вместо имени пользователя.

В таком случае пользовательскую модель можно определить так:

from django.db import models
from django.core.mail import send_mail
from django.contrib.auth.models import PermissionsMixin
from django.contrib.auth.base_user import AbstractBaseUser
from django.utils.translation import ugettext_lazy as _

from .managers import UserManager


class User(AbstractBaseUser, PermissionsMixin):
    email = models.EmailField(_('email'), unique=True)
    first_name = models.CharField(_('name'), max_length=30, blank=True)
    last_name = models.CharField(_('surname'), max_length=30, blank=True)
    date_joined = models.DateTimeField(_('registered'), auto_now_add=True)
    is_active = models.BooleanField(_('is_active'), default=True)
    avatar = models.ImageField(upload_to='avatars/', null=True, blank=True)

    objects = UserManager()

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = []

    class Meta:
        verbose_name = _('user')
        verbose_name_plural = _('users')

    def get_full_name(self):
        '''
        Возвращает first_name и last_name с пробелом между ними.
        '''
        full_name = '%s %s' % (self.first_name, self.last_name)
        return full_name.strip()

    def get_short_name(self):
        '''
        Возвращает сокращенное имя пользователя.
        '''
        return self.first_name

    def email_user(self, subject, message, from_email=None, **kwargs):
        '''
        Отправляет электронное письмо этому пользователю.
        '''
        send_mail(subject, message, from_email, [self.email], **kwargs)

В коде все сделано так, чтобы сохранить новую пользовательскую модель как можно ближе к существующей модели пользователя. Поскольку мы наследуем от AbstractBaseUser, нужно определить несколько свойств и методов:

USERNAME_FIELD — строка, описывающая имя поля в модели пользователя, которая используется как идентификатор. Поле должно быть уникальным (то есть иметь значение unique=True, установленное в его определении);
REQUIRED_FIELDS — список имен полей, которые будут запрашиваться при создании пользователя через команду управления createsuperuser;
is_active — логический атрибут, указывающий, является ли пользователь активным;
get_full_name() — более длинный формальный идентификатор для пользователя. В этом примере будем использовать полное имя пользователя, но это может быть любая строка, которая идентифицирует пользователя;
get_short_name() — короткий «неофициальный идентификатор» пользователя. В нашем примере — имя пользователя.

Также нужно определить UserManager. Это связано с тем, что существующий менеджер определяет методы create_user и create_superuser.

from django.contrib.auth.base_user import BaseUserManager

class UserManager(BaseUserManager):
    use_in_migrations = True

    def _create_user(self, email, password, **extra_fields):
        """
        Создает и сохраняет пользователя с введенным им email и паролем.
        """
        if not email:
            raise ValueError('email должен быть указан')
        email = self.normalize_email(email)
        user = self.model(email=email, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_user(self, email, password=None, **extra_fields):
        extra_fields.setdefault('is_superuser', False)
        return self._create_user(email, password, **extra_fields)

    def create_superuser(self, email, password, **extra_fields):
        extra_fields.setdefault('is_superuser', True)

        if extra_fields.get('is_superuser') is not True:
            raise ValueError('Superuser must have is_superuser=True.')

        return self._create_user(email, password, **extra_fields)
		
Теперь последний шаг. Нужно обновить settings.py, а именно свойство AUTH_USER_MODEL:
AUTH_USER_MODEL = '<app_name>.User'

ссылаться на модель лучше:
tutor = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)


Расширение модели пользователя с помощью наследования AbstractUser

Здесь все довольно просто, поскольку класс django.contrib.auth.models.AbstractUser обеспечивает полную реализацию пользователя по умолчанию как абстрактную модель:

from django.contrib.auth.models import AbstractUser

class User(AbstractUser):
    bio = models.TextField(max_length=500, blank=True)
    location = models.CharField(max_length=30, blank=True)
    birth_date = models.DateField(null=True, blank=True)
	
Затем вам как и в предыдущем способе нужно обновить settings.py, определяя свойство AUTH_USER_MODEL:
AUTH_USER_MODEL = '<app_name>.User'





-----Агрегатные вычисления----------

Агрегатные вычисления затрагивают значения определенного поля всех записей, имеющихся в модели, или групп записей, удовлетворяющих какому-либо условию. К такого рода действиям относится вычисление числа объявлений, среднего арифметического цены, наименьшего и наибольшего значения цены и т. п.

Каждое из возможных действий, выполняемых при агрегатных вычислениях, представляется определенной агрегатной функцией. 

aggregate(<агрегатная функция 1>, ... <агрегатная функция n>)
В качестве результата возвращается словарь;

Если агрегатная функция передается как позиционный параметр:
from django.db.modeIs import Min
Bb. objects.aggregate(Min(’price’))
{'price min’: 40.0}

Если агрегатная функция передается как ключевой параметр:
from django.db.modeIs import Max
Bb.objects.aggregate(max_price=Max('price'))
{'max_price': 50000000.0}

В вызове метода aggregate() допускается задавать произвольное число агрегатных функций:
result = Bb.objects.aggregate(Min('price'), Max('price'))
result['price__min'], result['price__max']
(40.0, 50000000.0)

А использовав для указания именованный параметр (с позиционным такой номер не пройдет), — выполнять вычисления над результатами агрегатных функций:
result = Bb.objects.aggregate(diff=Max('price')-Min('price'))
result['diff']
49999960.0

Если нужно провести агрегатное вычисление по группам записей, сформированным согласно определенному критерию (например, узнать, сколько объявлений
находится в каждой рубрике), то следует применить метод annotate ():

annotate (<агрегатная функция 1>, ... <агрегатная функция n>)
В качестве результата возвращается новый набор записей; каждая запись из возвращенного набора содержит атрибут, имя которого генерируется по тем же правилам, что и ключ элемента в словаре, возвращенном методом aggregate Этот атрибут хранит результат выполнения агрегатной функции.


from django.db.models import Count
for r in Rubric.objects.annotate(Count('bb')):
	print(r.name, ': ', r.bb__count, sep='')
Бытовая техника: 2
Мебель: 1

То же самое, но теперь агрегатная функция указана в именованном параметре:
for r in Rubric.objects.annotate(cnt=Count('bb’)):
	print(r.name, r.cnt, sep=’’)
	
Бытовая техника: 1000.0
Мебель: 200.0
Недвижимость: 100000.0
Растения: None

Использовав именованный параметр, мы фактически создаем в наборе записей новое поле(поле с названием cnt, у рубрик которых нет записей это поле заполнится значением None). Следовательно, мы можем фильтровать записи по значению этого поля(т.е. убрать из вывода рубрики у которых это поле будет None):
for r in Rubric.objects.annotate(cnt=Count(’bb’),
								min=Min(’bb__price’)).filter(сnt__gt=0):
	print(r.name, ': ’, r.min, sep=’’)

Бытовая техника: 1000.0
Мебель: 200.0
Недвижимость: 100000.0



-------Использование в scratch файле доступа к моделям----------------

import os

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "diary.diary_project.settings")

import django
django.setup()

from diary.diary.models import Student
print(Student.objects.filter(school_class__class_number='1А'))


--------Celery: лучшие практики---------------------------------------------

1: Не используйте СУБД как ваш AMQP брокер

Предположим не такой уж гипотетический сценарий: у вас есть 4 фоновых воркера для обработки, которые вы помещаете в базу данных. Это значит что вы получаете 4 процесса, которые достаточно часто запрашивают базу о новых задачах, не говоря уже о том, что каждый из них может иметь собственные конкурирующие потоки. В некоторый момент времени вы понимаете, что растет задержка при обработке задач, а потому приходит больше новых задач чем завершается, необходимо увеличивать количество воркеров. Вдруг скорость вашей базы данных начинает «проседать» из-за огромного количества запросов воркеров к базе, дисковый ввод\вывод превышает заданные лимиты, а все это начинает влиять на ваше приложение, так как воркеры, фактически, устроили DDOS-атаку вашей базе.

2: Используйте больше очередей (т.е. не только одну, которая дается по умолчанию)

taskA и taskB, находясь в одной очереди могут делать совершенно разные вещи и таким образом одна из них может быть куда важнее другой, так почему они находятся все в одной корзине? Даже, если у вас один воркер, то представьте такую ситуацию что менее важная задача taskB окажется настолько массовой, что более важной задаче taskA воркер не сможет уделить необходимого внимания.

3: Используйте приоритеты воркеров

Путем решения проблемы, указанной выше является размещение задачи taskA в одной очереди, а taskB в другой и после этого присвоить x воркеров обработке очередь Q1, а остальных на обработку Q2, так как в нее приходит больше задач. Таким образом вы можете быть уверены, что задача taskB получит достаточно воркеров, а остальные тем временем будут обрабатывать менее приоритетную задачу, когда она придет, не провоцируя длительного ожидания и обработки.

CELERY_QUEUES = (
    Queue('default', Exchange('default'), routing_key='default'),
    Queue('for_task_A', Exchange('for_task_A'), routing_key='for_task_A'),
    Queue('for_task_B', Exchange('for_task_B'), routing_key='for_task_B'),
)

CELERY_ROUTES = {
    'my_taskA': {'queue': 'for_task_A', 'routing_key': 'for_task_A'},
    'my_taskB': {'queue': 'for_task_B', 'routing_key': 'for_task_B'},
}

celery worker -E -l INFO -n workerA -Q for_task_A
celery worker -E -l INFO -n workerB -Q for_task_B


4: используйте механизмы Celery для обработки ошибок

@app.task(bind=True, default_retry_delay=300, max_retries=5)

5: используйте Flower

6: Отслеживайте статус задачи, только если вам это необходимо

Статус задачи это информация о том успешно или нет завершилась задача. Она может быть полезна для некоторых статистических показателей. Важная вещь, которую следует понимать в данном случае: статус задачи это не результирующие данные и той работы, которая она выполняла

В большинстве проектов, которые я видел реально не заботились о данных по статусу задачи после ее завершения, используя базу данных sqlite, которую предлагается по умолчанию или лучше того тратили время на использование больших СУБД типа PostgreSQL. Зачем просто так нагружать базу данных своего приложения? Используйте CELERY_IGNORE_RESULT = True в вашем файле настроек celeryconfig.py и отбрасывайте такие данные.

7: не передавайте объекты базы данных\ORM в задачу

После обсуждения вышеизложенного на встречах локальных групп python разработчиков некоторые люди предложили включить дополнительный пункт в представленный список. О чем он? Вы не должны передавать объекты базы данных, например, модель пользователя в фоновую задачу, так как в сериализованном объекте могут оказаться уже устаревшие и некорректные данные. Если вам необходимо, то передавайте в задачу ID пользователя, а в самой задаче запрашивайте базу об этом пользователе.


-----------Заполнение Django данными по умолчанию-----------------

1. Заполнение с помощью пустой миграции 

Создадим пустую миграцию
python manage.py makemigrations user_profile –empty

Создадим функцию, которая будет вызываться при вызове этого файла миграции и наполнять базу:
from django.db import migrations, models


def client_types(apps, schema_editor):
    # Типы - наш перечень, который будет вставлен в БД
    types = ["Покупатель", "Продавец", "Покупатель и продавец"]
    # Попросим Django вытащить модель - класс ClientTypes из аппликейшена user_profile
    ClientTypes = apps.get_model("user_profile", "ClientTypes")
    
    #Теперь в цикле создаём экземпляры класса с указанными параметрами и сохраняем их 
    for t in types:
        cl_type = ClientTypes(client_type=t)
        cl_type.save()
		
вызываем встроенный метод RunPython и указываем, какую функцию вызвать в operations
    operations = [
        migrations.RunPython(client_types),
	]

2. Заполнение стандартными фикстурами

Создадим папку fixtures в папке приложения
В папку fixtures кладем например json вида
[
  {
    "model": "myapp.person",
    "pk": 1,
    "fields": {
      "first_name": "John",
      "last_name": "Lennon"
    }
  },
]
Вызываем  manage.py loaddata <fixturename>
В settings можно указать список FIXTURE_DIRS где искать фикстуры
https://docs.djangoproject.com/en/3.0/howto/initial-data/


